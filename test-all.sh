#!/bin/bash

# Sean Szumlanski
# COP 3502, Spring 2017

# ===========================
# TriePrediction: test-all.sh
# ===========================
# You can run this script at the command line like so:
#
#   bash test-all.sh
#
# For more details, see the assignment PDF.


################################################################################
# STARTUP PHASE
################################################################################

if [ ! -f test_launcher_std.c ]; then
	echo "Error: test_launcher_std.c not found."
	exit
elif [ ! -f test_launcher_unit.c ]; then
	echo "Error: test_launcher_unit.c not found."
	exit
elif [ ! -f TriePrediction.h ]; then
	echo "Error: TriePrediction.h not found."
	exit
elif [ ! -f TriePrediction.c ]; then
	echo "Error: TriePrediction.c not found."
	exit
fi

NUM_STANDARD_TESTS=9
NUM_UNIT_TESTS=7

pass=0
total_tests=0


################################################################################
# EXECUTE STANDARD TEST CASES
################################################################################

echo "============================"
echo "RUNNING STANDARD TEST CASES:"
echo "============================"

NUM_TEST_CASES=$NUM_STANDARD_TESTS

for i in `seq -f "%02g" 1 $NUM_TEST_CASES`;
do
	echo -n "Checking ./a.out corpus$i.txt input$i.txt ... "
	total_tests=`expr $total_tests + 1`

	# Attempt to compile.
	gcc TriePrediction.c test_launcher_std.c 2> /dev/null
	compile_val=$?
	if [[ $compile_val != 0 ]]; then
		echo "fail (failed to compile)"
		continue
	fi

	# Run program. Capture return value to check whether it crashes.
	./a.out corpus$i.txt input$i.txt > myoutput$i.txt 2> /dev/null
	execution_val=$?
	if [[ $execution_val != 0 ]]; then
		echo "fail (program crashed)"
		continue
	fi

	# Run diff and capture its return value.
	diff myoutput$i.txt output$i.txt > /dev/null
	diff_val=$?
	
	# Output results based on diff's return value.
	if  [[ $diff_val != 0 ]]; then
		echo "fail (output does not match)"
	else
		echo "PASS!"
		pass=`expr $pass + 1`
	fi
done

# Clean up the output files generated by these test cases.
for i in `seq -f "%02g" 1 $NUM_TEST_CASES`;
do
	rm -f myoutput$i.txt
done

rm -f a.out


################################################################################
# EXECUTE UNIT TEST CASES
################################################################################

echo ""
echo "========================"
echo "RUNNING UNIT TEST CASES:"
echo "========================"

NUM_TEST_CASES=$NUM_UNIT_TESTS

for i in `seq -f "%02g" 1 $NUM_TEST_CASES`;
do
	echo -n "Checking unit_test$i.c ... "
	total_tests=`expr $total_tests + 1`

	# Attempt to compile.
	gcc TriePrediction.c test_launcher_unit.c unit_test$i.c 2> /dev/null
	compile_val=$?
	if [[ $compile_val != 0 ]]; then
		echo "fail (failed to compile)"
		continue
	fi

	# Run program. Capture return value to check whether it crashes.
	./a.out > myoutput$i.txt 2> /dev/null
	execution_val=$?
	if [[ $execution_val != 0 ]]; then
		echo "fail (program crashed)"
		continue
	fi

	# Run diff and capture its return value.
	diff myoutput$i.txt unit_output$i.txt > /dev/null
	diff_val=$?
	
	# Output results based on diff's return value.
	if  [[ $diff_val != 0 ]]; then
		echo "fail (output does not match)"
	else
		echo "PASS!"
		pass=`expr $pass + 1`
	fi
done

# Clean up the output files generated by these test cases.
for i in `seq -f "%02g" 1 $NUM_TEST_CASES`;
do
	rm -f myoutput$i.txt
done

rm -f a.out


################################################################################
# RUN STANDARD TESTS THROUGH VALGRIND
################################################################################

echo ""
echo "================================================="
echo "CHECKING FOR MEMORY LEAKS IN STANDARD TEST CASES:"
echo "================================================="

NUM_TEST_CASES=$NUM_STANDARD_TESTS

for i in `seq -f "%02g" 1 $NUM_TEST_CASES`;
do
	echo -n "Checking ./a.out corpus$i.txt input$i.txt ... "
	total_tests=`expr $total_tests + 1`

	# Attempt to compile.
	gcc TriePrediction.c test_launcher_std.c 2> /dev/null
	compile_val=$?
	if [[ $compile_val != 0 ]]; then
		echo "fail (failed to compile)"
		continue
	fi

	# Run program through valgrind. Check output for indication of memory leaks.
	valgrind --leak-check=yes ./a.out corpus$i.txt input$i.txt > myoutput$i.txt 2> err.log
	grep --silent "no leaks are possible" err.log
	valgrindfail=$?

	if [[ $valgrindfail != 0 ]]; then
		echo "fail (memory leak detected)"
	else
		echo "PASS!"
		pass=`expr $pass + 1`
	fi
done

# Clean up the output files generated by these test cases.
for i in `seq -f "%02g" 1 $NUM_TEST_CASES`;
do
	rm -f myoutput$i.txt
done

rm -f a.out
rm -f err.log


################################################################################
# RUN UNIT TESTS THROUGH VALGRIND
################################################################################

echo ""
echo "============================================="
echo "CHECKING FOR MEMORY LEAKS IN UNIT TEST CASES:"
echo "============================================="

NUM_TEST_CASES=$NUM_UNIT_TESTS

for i in `seq -f "%02g" 1 $NUM_TEST_CASES`;
do
	echo -n "Checking unit_test$i.c ... "
	total_tests=`expr $total_tests + 1`

	# Attempt to compile.
	gcc TriePrediction.c test_launcher_unit.c unit_test$i.c 2> /dev/null
	compile_val=$?
	if [[ $compile_val != 0 ]]; then
		echo "fail (failed to compile)"
		continue
	fi

	# Run program through valgrind. Check output for indication of memory leaks.
	valgrind --leak-check=yes ./a.out > myoutput$i.txt 2> err.log
	grep --silent "no leaks are possible" err.log
	valgrindfail=$?

	if [[ $valgrindfail != 0 ]]; then
		echo "fail (memory leak detected)"
	else
		echo "PASS!"
		pass=`expr $pass + 1`
	fi
done

# Clean up the output files generated by these test cases.
for i in `seq -f "%02g" 1 $NUM_TEST_CASES`;
do
	rm -f myoutput$i.txt
done

rm -f a.out
rm -f err.log


################################################################################
# TEAR-DOWN PHASE
################################################################################

# n/a


################################################################################
# FINAL OUTPUT (IF APPLICABLE)
################################################################################

if [ $pass -eq $total_tests ]; then
	echo ""
	echo "Congratulations! You appear to be passing all the test cases! Now, have you"
	echo "considered writing some additional ones of your own?"
fi
